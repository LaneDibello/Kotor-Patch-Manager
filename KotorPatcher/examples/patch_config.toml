# Example patch_config.toml
# This file is generated by KPatchCore at installation time
# It tells kotor_patcher.dll which patches to load and where to hook them

# ===== Example 1: INLINE Hook (Default, Safest) =====
# The patcher automatically saves all CPU state (registers + flags),
# calls your patch function with a PatchContext pointer, then restores state.
# Your patch can inspect and modify the context.

[[patches]]
id = "widescreen-fix"
dll = "patches/widescreen-fix.dll"

  [[patches.hooks]]
  address = 0x401234
  function = "FixedResolutionHandler"
  original_bytes = [0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x20]
  type = "inline"  # Optional: this is the default
  preserve_registers = true  # Optional: default is true
  preserve_flags = true      # Optional: default is true

  # Example: Hook that modifies return value (EAX)
  [[patches.hooks]]
  address = 0x405678
  function = "CustomAspectRatio"
  original_bytes = [0x8B, 0x44, 0x24, 0x04, 0x8B, 0x4C, 0x24, 0x08]
  type = "inline"
  exclude_from_restore = ["eax"]  # Allow patch to modify EAX (return value)

# ===== Example 2: INLINE Hook with Register Modifications =====
# This patch wants to modify multiple registers (e.g., setting output parameters)

[[patches]]
id = "bugfix-pack"
dll = "patches/bugfix-pack.dll"

  [[patches.hooks]]
  address = 0x4089AB
  function = "FixInventoryBug"
  original_bytes = [0x89, 0x45, 0xF8, 0x8B, 0x45, 0xF8]
  type = "inline"
  exclude_from_restore = ["eax", "edx"]  # Patch can modify both EAX and EDX

  # Example: Simple inspection hook (doesn't modify anything)
  [[patches.hooks]]
  address = 0x40F123
  function = "LogDialogCall"
  original_bytes = [0x83, 0xC4, 0x08, 0xC3]
  type = "inline"
  # No exclude_from_restore needed - all registers restored automatically

# ===== Example 3: REPLACE Hook (Legacy Mode) =====
# For advanced users who want full control. No automatic state management.
# Your patch function must handle everything (stack frame, register preservation, etc.)

[[patches]]
id = "advanced-asm-patch"
dll = "patches/advanced.dll"

  [[patches.hooks]]
  address = 0x450000
  function = "MyCustomAssemblyFunction"
  original_bytes = [0x55, 0x8B, 0xEC]
  type = "replace"  # Direct JMP, no wrapper
  # preserve_registers ignored for REPLACE type
  # exclude_from_restore ignored for REPLACE type

# ===== Notes on Hook Types =====
#
# INLINE (recommended):
#   - Easiest to use - write simple C code
#   - Automatic state management
#   - Full inspection of CPU state via PatchContext
#   - Can selectively modify registers via exclude_from_restore
#   - Patch signature: void MyPatch(PatchContext* ctx)
#
# REPLACE (advanced):
#   - No wrapper overhead
#   - Patch must handle everything manually
#   - Good for assembly experts or performance-critical hooks
#   - Patch signature: depends on hooked function's calling convention
#
# WRAP (future - not fully implemented):
#   - Calls patch, then executes original function
#   - Requires detour trampoline system (Phase 2)
#   - Good for "before/after" hooks

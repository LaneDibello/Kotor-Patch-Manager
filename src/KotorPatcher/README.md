# KotorPatcher Runtime DLL

This is the C++ runtime component that gets injected into the KOTOR game process and applies patches at runtime.

## Overview

`KotorPatcher.dll` is loaded by KPatchLauncher via DLL injection and:
1. Reads `patch_config.toml` from the game directory
2. Applies patches according to their configured hook types
3. For DETOUR hooks: Loads patch DLLs and writes JMP trampolines to redirect execution
4. For SIMPLE hooks: Directly replaces bytes in memory (no DLL required)

## Architecture

### Injection Method

**KPatchLauncher** (recommended approach):
- Uses `CreateProcess` with `CREATE_SUSPENDED` flag
- Hijacks main thread to inject `KotorPatcher.dll`
- Resumes thread after injection
- No permanent modification to game executable

### Components

- **dllmain.cpp**: DLL entry point, calls initialization on `DLL_PROCESS_ATTACH`
- **config.h/.cpp**: Parses `patch_config.toml` using Tomlyn (C# TOML parser, via C++/CLI)
- **patcher.h/.cpp**: Core patching logic - applies hooks based on type
- **wrappers/**: Runtime code generation for DETOUR hooks
  - **wrapper_base.h**: Abstract interface for platform-specific wrappers
  - **wrapper_context.h**: Platform-independent context structure
  - **wrapper_x86_win32.cpp**: Current implementation (Windows 32-bit x86)

### Dependencies

- **Windows API**: `VirtualAlloc`, `VirtualProtect`, `FlushInstructionCache`, `LoadLibrary`, `GetProcAddress`
- **Tomlyn** (via C++/CLI): TOML parsing library for configuration

## Hook Types

The system supports two types of hooks:

### DETOUR

**Full-featured hook with wrapper system:**
- Automatically saves all CPU state (registers + EFLAGS)
- Generates runtime wrapper that calls your patch function
- Executes stolen bytes (original instructions that were overwritten)
- Returns to game code seamlessly
- Supports parameter extraction from registers/stack
- Your function receives extracted parameters as normal C function arguments

**Patch Function Example:**
```cpp
extern "C" __declspec(dllexport)
void MyPatch_Hook(const char* stringParam, int x, int y, float life) {
    // Clean C code - no assembly required
    // Parameters automatically extracted by wrapper system
    OutputDebugStringA(stringParam);
}
```

**Configuration (hooks.toml):**
```toml
[[hooks]]
address = 0x005cb41c
function = "MyPatch_Hook"
original_bytes = [0x8d, 0x4c, 0x24, 0x0c, 0xc7, 0x44, 0x24, 0x1c, 0xff, 0xff, 0xff, 0xff]
type = "detour"
exclude_from_restore = []  # Optional: specify registers not to restore

[[hooks.parameters]]
source = "eax"
type = "pointer"

[[hooks.parameters]]
source = "esp+0"
type = "int"
```

**Parameter Types:**
- `"int"` - 32-bit integer (DWORD)
- `"float"` - 32-bit floating point
- `"pointer"` - Pointer/address (treated as void*)

**Parameter Sources:**
- `"eax"`, `"ebx"`, `"ecx"`, `"edx"`, `"esi"`, `"edi"`, `"ebp"` - CPU registers
- `"esp+N"` - Stack offset (N bytes from ESP)

### SIMPLE

**Direct byte replacement in memory:**
- No DLL required
- Simply replaces original bytes with replacement bytes
- Perfect for constant changes, NOPs, or simple instruction swaps
- Minimal overhead - just a memory write

**Configuration (hooks.toml):**
```toml
[[hooks]]
address = 0x006a89b2
type = "simple"
original_bytes = [0x68, 0x00, 0x00, 0x80, 0x3f]  # PUSH 1.0f
replacement_bytes = [0x68, 0x00, 0x00, 0x00, 0x3f]  # PUSH 0.5f
```

**Use Cases:**
- Changing constants (float/int values)
- Replacing instructions with NOPs
- Simple opcode swaps
- Any scenario where you just need to change bytes

**Example:** See `Patches/SemiTransparentLetterbox` for a real-world SIMPLE hook example.

## Configuration Format

The runtime reads `patch_config.toml` generated by KPatchCore:

```toml
[[patches]]
id = "patch-name"
dll = "patches/patch.dll"  # Only required for DETOUR hooks

  [[patches.hooks]]
  address = 0x401234
  type = "detour"  # or "simple"
  function = "MyPatchFunction"  # DETOUR only
  original_bytes = [0x55, 0x8B, 0xEC]

  # DETOUR-specific fields:
  [[patches.hooks.parameters]]
  source = "eax"
  type = "pointer"

  # SIMPLE-specific fields:
  replacement_bytes = [0x90, 0x90, 0x90]  # SIMPLE only
```

## How It Works

### Initialization Flow

1. KPatchLauncher injects `KotorPatcher.dll` into suspended game process
2. Windows calls `DllMain` with `DLL_PROCESS_ATTACH`
3. Initialization begins:
   - Locates DLL's own path
   - Reads `patch_config.toml` from game directory
   - Parses configuration using Tomlyn
   - Applies all patches according to their types

### DETOUR Hook Application

For each DETOUR hook:
1. **Load DLL**: `LoadLibrary(patch.dllPath)`
2. **Get Function**: `GetProcAddress(handle, patch.functionName)`
3. **Verify Bytes**: Check that bytes at hook address match `original_bytes`
4. **Generate Wrapper**: Create runtime wrapper stub with parameter extraction
5. **Write Trampoline**: Write 5-byte (minimum) JMP to wrapper
6. **Stolen Bytes**: Wrapper executes original instructions that were overwritten
7. **Return**: Wrapper jumps back to continue game execution

### SIMPLE Hook Application

For each SIMPLE hook:
1. **Verify Bytes**: Check that bytes at hook address match `original_bytes`
2. **Make Writable**: `VirtualProtect` to `PAGE_EXECUTE_READWRITE`
3. **Replace Bytes**: `memcpy` replacement bytes over original bytes
4. **Restore Protection**: `VirtualProtect` back to original protection
5. **Flush Cache**: `FlushInstructionCache` to ensure CPU sees changes

### Wrapper System (DETOUR Hooks)

The wrapper system automatically generates x86 machine code at runtime:

#### Generated Code Structure
```asm
wrapper_stub:
    pushad              ; Save all 8 general-purpose registers
    pushfd              ; Save EFLAGS

    ; Extract parameters and push onto stack
    ; (based on hooks.parameters configuration)
    mov eax, [esp+N]    ; Extract parameter from register/stack
    push eax            ; Push as function argument

    ; Call patch function
    call patch_function
    add esp, N          ; Clean up arguments

    ; Execute stolen bytes (original instructions)
    ; These are the instructions that were overwritten by the JMP
    <original instructions here>

    ; Restore state (respecting exclude_from_restore)
    popfd               ; Restore flags
    popad               ; Restore registers

    jmp [return_address]  ; Jump back to game code
```

#### Parameter Extraction

The wrapper automatically extracts parameters before calling your function:

```toml
[[hooks.parameters]]
source = "eax"
type = "pointer"
```

Generates:
```asm
mov eax, [saved_eax_location]
push eax
```

#### Stolen Bytes

Original instructions at the hook point are:
1. **Disassembled** to determine instruction boundaries
2. **Copied** into the wrapper's executable memory
3. **Executed** by the wrapper after your patch function returns
4. This allows your patch to run without losing the original functionality

## Trampoline Mechanism

A **trampoline** is a JMP instruction that redirects execution:

```
Original game code at 0x401234:
  55 8B EC 83 EC 20  (push ebp; mov ebp,esp; sub esp,0x20)

After patching:
  E9 C7 FD 0F 00 ... (jmp 0x501000 - wrapper in allocated memory)

Offset calculation:
  offset = target_address - (hook_address + 5)
  offset = 0x501000 - (0x401234 + 5) = 0x0FFDC7
```

**Memory Safety**:
- `VirtualProtect` to make code writable
- `memcpy` to write new instruction
- `VirtualProtect` to restore original protection
- `FlushInstructionCache` to ensure CPU sees changes

## Building

### Requirements

- Visual Studio 2022
- Windows SDK 10.0
- C++17 compiler
- C++/CLI support (for Tomlyn integration)

### Build Steps

Use Visual Studio or MSBuild:

```bash
msbuild KotorPatcher.vcxproj /p:Configuration=Release /p:Platform=Win32
```

**Important:**
- **Platform**: Must be Win32 (x86) - KOTOR is a 32-bit game
- **Configuration**: Debug or Release

### Output

- **Debug**: `Debug/KotorPatcher.dll`
- **Release**: `Release/KotorPatcher.dll`

## Testing

### Using DebugView

The patcher uses `OutputDebugStringA` for logging. View with:
- [DebugView](https://learn.microsoft.com/en-us/sysinternals/downloads/debugview) (SysInternals)
- Visual Studio debugger (Debug Output window)

Example output:
```
[KotorPatcher] Initializing...
[KotorPatcher] Loaded config with 2 patches
[KotorPatcher] Applying patch: semi-transparent-letterbox
[KotorPatcher] Applied SIMPLE hook at 0x006a89b2
[KotorPatcher] Applying patch: enable-aur-post-string
[KotorPatcher] Applied DETOUR hook at 0x005cb41c
[KotorPatcher] Initialization complete
```

### Integration Testing

1. Create a patch using KPatchCore
2. Use KPatchLauncher to inject and launch game
3. Monitor DebugView for patcher output
4. Verify patch behavior in-game

## Error Handling

### Philosophy

**Runtime errors should not crash the game**. The patcher follows these principles:

1. **Graceful degradation**: If patches fail to load, game runs without them
2. **Detailed logging**: All errors logged via `OutputDebugString`
3. **Fail-fast on verification**: If original bytes don't match, abort patching
4. **No exceptions**: All errors handled with return values

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| "Failed to open config file" | `patch_config.toml` not found | Ensure config exists in game directory |
| "TOML parse error" | Malformed TOML syntax | Validate config with TOML parser |
| "Failed to load: [dll]" | Patch DLL not found or wrong architecture | Check DLL path and ensure it's 32-bit |
| "Function not found" | Exported function doesn't exist | Verify DLL exports with `dumpbin /exports` |
| "Original bytes mismatch" | Wrong game version or already patched | Check game version, verify not double-patched |
| "Failed to write hook" | Memory protection error | Check antivirus, run as administrator |

## Security Considerations

1. **Byte verification**: Always verify original bytes before patching to prevent corruption
2. **Memory protection**: Restore original protection after patching
3. **Isolated patches**: Each patch DLL runs in isolation
4. **Path validation**: DLL paths are relative to game directory
5. **No arbitrary code**: Only loads DLLs specified in trusted config

## Performance

The runtime is designed to be **lightweight**:

- **Initialization**: <10ms typical (depends on number of patches)
- **Memory overhead**: ~100KB for patcher DLL + patch DLLs + wrapper stubs
- **Runtime overhead**: None after initialization (SIMPLE hooks have zero overhead, DETOUR hooks are direct JMPs)

## Current Limitations

### No Mid-Function Original Function Calls

The current implementation **cannot call the original function** that was replaced:

**What This Means:**
- DETOUR hooks execute stolen bytes but cannot call the original function as a whole
- Patches must either:
  - Hook at function entry and completely replace behavior
  - Hook mid-function and execute only the stolen bytes (limited use case)
- Cannot do true "wrap" patterns (call original before/after)

**Compatibility:**
- Patches targeting different addresses: ✅ **Compatible**
- Patches targeting overlapping addresses: ❌ **Incompatible** (prevented by verification)
- Multiple patches to same address: ❌ **Incompatible**

## Troubleshooting

### Patcher Not Loading

1. Check that KPatchLauncher successfully injected the DLL
2. Use DebugView to see initialization messages
3. Ensure `KotorPatcher.dll` is in game directory or with launcher

### Patches Not Applied

1. Check `patch_config.toml` exists and is valid TOML
2. Use DebugView to see error messages
3. Verify patch DLLs exist at specified paths
4. Ensure game version matches (original_bytes check)

### Game Crashes

1. Check original_bytes in config match actual game bytes
2. Verify patch DLLs are not corrupted
3. Ensure patch functions have correct calling convention (`__stdcall` or `__cdecl`)
4. Check for memory corruption in patch code
5. Verify patch DLL is 32-bit (x86) architecture

## Examples

### DETOUR Hook Example

See `Patches/EnableScriptAurPostString` for a complete DETOUR hook example with parameter extraction.

### SIMPLE Hook Example

See `Patches/SemiTransparentLetterbox` for multiple SIMPLE hooks that change alpha values.

### Script Extender Example

See `Patches/ScriptExtender` for a complex example that adds new script functions to the game.

## License

Part of the KOTOR Patch Manager project. See main repository for license information.

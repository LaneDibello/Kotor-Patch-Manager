Great idea to switch to Claude Code for the implementation work! Unfortunately, there's no direct way to transfer conversation context, but I'll create a comprehensive project brief for you.

---

# KOTOR Patcher Project Brief

## Project Overview
A modular, cross-platform patching system for Star Wars: Knights of the Old Republic (KOTOR). The system allows users to apply community-created patches to the game without redistributing copyrighted content, using a DLL injection approach with runtime trampolines.

## Core Requirements
1. **Consistency**: Unified patching scheme using an additional executable memory block (DLL injection)
2. **Reversibility**: Patched executables can be restored to original state via backup
3. **Simplicity**: User-friendly tool for non-technical modders
4. **Extensibility**: Community modders can create compatible patches
5. **Portability**: Support multiple versions (GOG, Steam, Mac, Linux) and KOTOR 1 & 2
6. **Legality**: No redistribution of BioWare IP; users provide their own game installation

## Technical Architecture

### High-Level Design
The system uses a **two-component architecture**:

1. **Installation Time (C# tooling)**:
   - Minimal modification to game EXE (add one DLL import)
   - Copy runtime patcher DLL to game folder
   - Copy community patch DLLs to patches subfolder
   - Generate configuration file listing enabled patches
   - Maintain backup of original EXE

2. **Runtime (C++ DLL loaded by game)**:
   - Reads configuration at game startup
   - Dynamically loads enabled patch DLLs
   - Writes trampolines (JMP instructions) at specified addresses
   - Redirects game code execution to patch functions

### Why This Approach?
- **Minimal EXE modification**: Only add `KotorPatcher.dll` to import table (easily reversible)
- **Enable/disable patches without touching EXE**: Just edit config file
- **No code cave hunting**: Patch code lives in DLLs with unlimited space
- **Compatibility**: Patches don't conflict unless hooking exact same address
- **Standard tooling**: Patches are normal DLLs, debuggable with standard tools

## Repository Structure (Monorepo)

```
kotor-patcher/
├── runtime/                        # C++ component (KotorPatcher.dll)
│   ├── include/
│   │   ├── patcher.h              # Main patcher interface
│   │   ├── trampoline.h           # Memory patching/trampoline writing
│   │   └── config_reader.h        # TOML config parsing
│   ├── src/
│   │   ├── dllmain.cpp            # DLL entry point
│   │   ├── patcher.cpp            # Patch loading and application
│   │   ├── trampoline.cpp         # Low-level memory manipulation
│   │   └── config_reader.cpp      # (TODO) TOML parsing implementation
│   └── KotorPatcher.vcxproj       # Visual Studio C++ project
├── src/                            # C# components
│   ├── KPatchCore/                # C# Class Library - Business logic
│   │   ├── Models/
│   │   │   ├── GameVersion.cs     # Represents game version/platform
│   │   │   ├── PatchManifest.cs   # Patch metadata
│   │   │   ├── Hook.cs            # Hook point definition
│   │   │   ├── PatchConfig.cs     # Runtime configuration
│   │   │   ├── BackupInfo.cs      # Backup metadata
│   │   │   └── PatchResult.cs     # Result/error info
│   │   ├── Parsers/
│   │   │   ├── ManifestParser.cs  # Parse patch TOML manifests
│   │   │   └── ExecutableParser.cs # PE/Mach-O file reading
│   │   ├── Validators/
│   │   │   ├── PatchValidator.cs  # Validate patch manifests
│   │   │   ├── DependencyValidator.cs # Check dependencies/conflicts
│   │   │   ├── GameVersionValidator.cs # Verify game version
│   │   │   └── HookValidator.cs   # Validate hook points
│   │   ├── Detectors/
│   │   │   ├── GameDetector.cs    # Detect game version from EXE
│   │   │   └── GameLocator.cs     # Find game installations
│   │   ├── Applicators/
│   │   │   ├── BackupManager.cs   # Create/restore backups
│   │   │   ├── LoaderInjector.cs  # Modify EXE to load patcher DLL
│   │   │   ├── PatchApplicator.cs # Orchestrate patch application
│   │   │   └── PatchRemover.cs    # Remove patches/restore backup
│   │   ├── Managers/
│   │   │   ├── PatchRepository.cs # Manage collection of patches
│   │   │   └── PatchOrchestrator.cs # High-level API facade
│   │   └── KPatchCore.csproj
│   ├── KPatchCore.Tests/          # (Future) Unit tests
│   │   └── KPatchCore.Tests.csproj
│   ├── KPatchConsole/             # C# Console App - CLI tool
│   │   ├── Commands/
│   │   │   ├── InstallCommand.cs  # Install patches
│   │   │   ├── UninstallCommand.cs # Remove patches
│   │   │   └── ListCommand.cs     # List available patches
│   │   ├── Program.cs
│   │   └── KPatchConsole.csproj
│   └── KPatchGUI/                 # (Future) Avalonia UI application
│       └── KPatchGUI.csproj
├── docs/
│   ├── architecture.md            # This document
│   ├── user-guide.md              # For end users
│   └── modder-guide.md            # For patch creators
├── examples/
│   └── sample-patches/            # Example patches for testing
├── KotorPatcher.sln               # Visual Studio solution
└── README.md
```

## Component Details

### 1. Runtime Component: KotorPatcher.dll (C++)

**Purpose**: Lightweight DLL that gets injected into the game process and applies patches at runtime.

**Key Responsibilities**:
- Read `patch_config.toml` from game directory
- Dynamically load enabled patch DLLs using `LoadLibrary`
- Get patch function addresses using `GetProcAddress`
- Verify original bytes at hook points match expected values
- Write 5-byte JMP trampolines to redirect execution to patch functions
- Handle errors gracefully (don't crash the game)

**Implementation Details**:

**Initialization Flow**:
1. `DllMain` called with `DLL_PROCESS_ATTACH` when game loads the DLL
2. `InitializePatcher()` is invoked
3. Find DLL's own location using `GetModuleHandleA("KotorPatcher.dll")` + `GetModuleFileNameA`
4. Extract directory path to locate `patch_config.toml`
5. Parse config to get list of enabled patches
6. For each patch:
   - Load patch DLL
   - Get function addresses
   - Verify original bytes
   - Write trampolines

**Trampoline Mechanism**:
- **5-byte relative JMP**: `E9 [4-byte offset]`
- Offset calculation: `target_address - (hook_address + 5)`
- Memory protection: Use `VirtualProtect` to make code writable
- Cache coherency: Use `FlushInstructionCache` to ensure CPU sees new code

**Example**:
```
Original game code at 0x401234:
  55 8B EC 83 EC 20  (push ebp; mov ebp,esp; sub esp,0x20)

After patching:
  E9 C7 FD 0F 00     (jmp to patch function at 0x501000)
  
Patch function executes, then returns to game's caller
```

**Current Implementation Status**:
- ✅ `dllmain.cpp`: Entry point implemented
- ✅ `patcher.h`: Header with main interfaces
- ✅ `patcher.cpp`: Core patching logic implemented
- ✅ `trampoline.h`: Trampoline interface defined
- ✅ `trampoline.cpp`: Memory patching implemented (WriteJump, VerifyBytes, memory protection)
- ❌ `config_reader.cpp`: TODO - needs TOML parsing library

**Dependencies**:
- Windows API (kernel32.dll) for LoadLibrary, VirtualProtect, etc.
- TOML parser (need to choose: toml++, cpptoml, or similar)

**Build Configuration**:
- Target: Win32 (x86) - KOTOR is 32-bit
- Output: `KotorPatcher.dll`
- Runtime Library: /MT (static linking for minimal dependencies)

### 2. Core Library: KPatchCore (C#)

**Purpose**: Cross-platform business logic library that handles all patching operations at installation time.

**Key Responsibilities**:
- Parse patch manifests (TOML format)
- Detect game version and locate installations
- Validate patches (dependencies, conflicts, version compatibility)
- Modify game EXE to import `KotorPatcher.dll`
- Manage backups and restoration
- Generate `patch_config.toml` for runtime
- Provide tooling for patch authors to build patches

**Target Framework**: .NET 8.0 (cross-platform)

**Key NuGet Dependencies**:
- `PeNet` or `AsmResolver`: PE file manipulation (modify import table)
- `Tomlyn`: TOML parsing and generation
- `System.IO.Compression`: For .kpatch archive handling

**Public API** (PatchOrchestrator):
```csharp
var orchestrator = new PatchOrchestrator("/path/to/patches");

// Install patches
var result = orchestrator.InstallPatches(
    gamePath: "C:/Games/KOTOR",
    patchIds: new[] { "bugfix-pack", "widescreen-fix" }
);

// Remove patches
orchestrator.UninstallPatches("C:/Games/KOTOR");

// Query patches
var patches = orchestrator.GetAvailablePatches();
```

**Current Implementation Status**:
- ❌ All classes TODO - architecture defined but not implemented

### 3. CLI Tool: KPatchConsole (C#)

**Purpose**: Command-line interface for installing/managing patches without GUI.

**Example Usage**:
```bash
# Install patches
kpatch install --game "C:\Games\KOTOR" --patches bugfix-pack widescreen-fix

# List available patches
kpatch list

# Uninstall all patches
kpatch uninstall --game "C:\Games\KOTOR"

# Verify installation
kpatch verify --game "C:\Games\KOTOR"
```

**Dependencies**:
- References `KPatchCore`
- Optional: `System.CommandLine` for modern CLI parsing

**Current Implementation Status**:
- ❌ TODO - basic structure defined but not implemented

### 4. GUI Application: KPatchGUI (Avalonia UI)

**Purpose**: User-friendly cross-platform GUI for patch management.

**Target Framework**: .NET 8.0 + Avalonia UI

**Features**:
- Visual patch browser
- Drag-and-drop patch installation
- Dependency visualization
- One-click backup/restore
- Game version detection

**Current Implementation Status**:
- ❌ Future work - not started yet

## Patch Distribution Format

### .kpatch Archive Structure
Patches are distributed as `.kpatch` files (ZIP archives):

```
my_patch.kpatch (ZIP file)
├── manifest.toml          # Metadata
├── hooks.toml             # Hook point definitions
└── binaries/
    ├── windows_x86.dll    # Minimal DLL with patch code
    ├── windows_x64.dll    # (Future) For 64-bit versions
    ├── macos_x86_64.dylib # (Future) macOS Intel
    └── macos_arm64.dylib  # (Future) macOS Apple Silicon
```

### manifest.toml Example
```toml
[patch]
id = "widescreen-fix"
name = "Widescreen Resolution Fix"
version = "1.2.0"
author = "CommunityModder"
description = "Enables 16:9 and 21:9 resolutions"

requires = []  # List of required patch IDs
conflicts = ["old-widescreen-mod"]  # Incompatible patches

[patch.supported_versions]
[patch.supported_versions.kotor1_gog_103]
game_hash = "abc123..."
file_size = 5242880
```

### hooks.toml Example
```toml
[[hooks]]
address = 0x401234
type = "jmp"  # or "call"
function = "FixedResolutionHandler"  # Exported function name in DLL
original_bytes = "55 8B EC 83 EC 20"  # For verification

[[hooks]]
address = 0x405678
type = "jmp"
function = "CustomAspectRatio"
original_bytes = "8B 44 24 04 8B 4C 24 08"
```

### Patch DLL Structure
Community patch DLLs are minimal:
- PE/Mach-O header
- Single executable section with patch code
- Export table with function names
- No imports, resources, or relocations needed

**Example patch function**:
```asm
; Exported as "FixedResolutionHandler"
global _FixedResolutionHandler
_FixedResolutionHandler:
    push ebp
    mov ebp, esp
    
    ; Patch logic here
    ; (fix the resolution bug)
    
    pop ebp
    ret  ; Returns to game's caller
```

## Installation Process

### What KPatchCore Does:

1. **Detect Game Version**:
   - Hash EXE file
   - Check file size
   - Match against known versions database

2. **Validate Patches**:
   - Parse all patch manifests
   - Check dependencies are satisfied
   - Verify no conflicts
   - Ensure patches support detected game version

3. **Create Backup**:
   - Copy original `swkotor.exe` to `swkotor.exe.backup`
   - Store hash and metadata

4. **Inject Loader**:
   - Modify EXE's PE import table
   - Add entry for `KotorPatcher.dll`
   - This is the ONLY modification to the EXE

5. **Deploy Files**:
   - Copy `KotorPatcher.dll` to game folder
   - Copy enabled patch DLLs to `patches/` subfolder
   - Extract any patch resources

6. **Generate Config**:
   - Write `patch_config.toml` listing:
     - Enabled patches
     - Hook addresses
     - Function names
     - Original bytes for verification

### Example patch_config.toml
```toml
[[patches]]
id = "widescreen-fix"
dll = "patches/widescreen-fix.dll"

[[patches.hooks]]
address = 0x401234
function = "FixedResolutionHandler"
original_bytes = [0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x20]

[[patches.hooks]]
address = 0x405678
function = "CustomAspectRatio"
original_bytes = [0x8B, 0x44, 0x24, 0x04, 0x8B, 0x4C, 0x24, 0x08]

[[patches]]
id = "bugfix-pack"
dll = "patches/bugfix-pack.dll"
# ... more hooks
```

## Runtime Process

### What Happens When User Launches Game:

1. **Windows Loader**:
   - Sees `KotorPatcher.dll` in import table
   - Loads it before game code runs

2. **KotorPatcher.dll Initialization**:
   - `DllMain` called with `DLL_PROCESS_ATTACH`
   - `InitializePatcher()` executes:
     - Find own location
     - Read `patch_config.toml`
     - For each enabled patch:
       - `LoadLibrary("patches/patch.dll")`
       - `GetProcAddress(handle, "FunctionName")`
       - Verify original bytes at hook address
       - Write 5-byte JMP trampoline

3. **Game Execution**:
   - Game code runs normally
   - When execution reaches patched address (e.g., 0x401234):
     - CPU executes JMP instruction
     - Jumps to patch function in DLL
     - Patch function executes
     - Returns to game's caller

## Game Version Support

### Target Versions (Priority Order):

**Phase 1** (Current Focus):
- KOTOR 1 - GOG - Windows - v1.03 - x86

**Phase 2** (Near Future):
- KOTOR 1 - Steam - Windows - v1.03 - x86
- KOTOR 1 - Mac - various versions

**Phase 3** (Future):
- KOTOR 2 - Various platforms
- 64-bit versions (if they exist)

### Version Detection Strategy:
Each version has unique characteristics:
- File size (exact match)
- SHA256 hash (most reliable)
- PE version resource (if available)
- File timestamp (last resort)

Store database of known versions:
```csharp
var knownVersions = new Dictionary<string, GameVersion> {
    ["abc123..."] = new GameVersion {
        Platform = Platform.Windows,
        Distribution = Distribution.GOG,
        Version = "1.03",
        Architecture = Architecture.x86,
        FileSize = 5242880
    },
    // ... more versions
};
```

## Error Handling Philosophy

### Installation Time (C# Code):
- **Fail fast**: If anything goes wrong, stop immediately
- **Revert on failure**: Restore backup if installation fails partway
- **Detailed errors**: Tell user exactly what went wrong and how to fix it
- **Validate everything**: Check all conditions before modifying files

### Runtime (C++ Code):
- **Graceful degradation**: If patches fail to load, let game run without them
- **Never crash the game**: Errors in patcher should not prevent game from running
- **Logging**: Write detailed logs for debugging, but don't show to user
- **Safety checks**: Verify everything before writing to memory

## Security Considerations

1. **No arbitrary code execution**: Patches must follow defined format
2. **Byte verification**: Always check original bytes before patching
3. **Memory protection**: Restore original protection after patching
4. **Backup validation**: Verify backup integrity before using
5. **Hash checking**: Ensure patches haven't been tampered with (future: signatures)

## Testing Strategy

### Unit Tests (KPatchCore.Tests):
- Manifest parsing
- Dependency resolution
- PE file manipulation
- Hash calculation
- Version detection

### Integration Tests:
- Full installation flow with test patches
- Backup/restore cycle
- Error handling paths

### Manual Testing:
- Run patched game and verify functionality
- Test with multiple patches enabled
- Verify compatibility with different KOTOR versions

## Build and Release Process

### Development Build:
1. Build C++ runtime: `msbuild runtime/KotorPatcher.vcxproj`
2. Build C# core: `dotnet build src/KPatchCore`
3. Build CLI: `dotnet build src/KPatchConsole`

### Release Package:
```
KotorPatcher-v1.0.0/
├── kpatch.exe              # CLI tool
├── KPatchCore.dll          # Business logic
├── runtime/
│   ├── KotorPatcher.dll   # Windows x86
│   └── kotor_patcher.dylib # (Future) macOS
├── patches/                # Empty - user adds patches here
├── docs/
│   ├── user-guide.pdf
│   └── quickstart.txt
└── examples/
    └── sample-patches/
```

### Distribution:
- GitHub Releases for main patcher tool
- Community patches distributed separately (Nexus Mods, etc.)
- Each patch is self-contained .kpatch file

## Current Development Status

### ✅ Completed:
- Architecture design
- Project structure in Visual Studio
- `KotorPatcher.dll` core implementation:
  - DLL entry point
  - Patch loading logic
  - Trampoline writing (memory patching)
  - Memory protection and verification

### 🚧 In Progress:
- Need to choose and integrate TOML parser for C++ runtime

### ❌ TODO (Priority Order):
1. Complete `config_reader.cpp` (TOML parsing)
2. Implement KPatchCore classes (C# business logic)
3. Build KPatchConsole (CLI tool)
4. Create example patches for testing
5. Test full installation flow
6. Write documentation
7. Implement KPatchGUI (Avalonia)
8. Add support for additional game versions
9. Implement advanced features (hot-reload, patch updates, etc.)

## Development Environment

- **IDE**: Visual Studio 2022
- **Languages**: C++ (runtime), C# (tooling)
- **Target Frameworks**: C++ Win32, .NET 8.0
- **Build System**: MSBuild (Visual Studio solution)
- **Version Control**: Git (monorepo)

## Key Design Decisions Made

1. **DLL injection over direct EXE patching**: Minimal modification, maximum flexibility
2. **Monorepo**: Unified versioning, atomic commits, easier refactoring
3. **C++ for runtime, C# for tooling**: Right tool for each job
4. **TOML for configuration**: Human-readable, well-supported
5. **Relative JMP trampolines**: Simple, reliable, 5 bytes
6. **ZIP-based .kpatch format**: Standard, easy to create/extract
7. **Avalonia for GUI**: True cross-platform, modern

## Next Immediate Steps

1. **Add TOML parser to C++ project**:
   - Choose library: toml++ (header-only, modern C++)
   - Add to project
   - Implement `config_reader.cpp`

2. **Test C++ runtime in isolation**:
   - Create dummy `patch_config.toml`
   - Create test patch DLL with simple function
   - Manually inject into KOTOR and verify trampolines work

3. **Start KPatchCore implementation**:
   - Begin with Models (simple data classes)
   - Then Parsers (read manifest files)
   - Then Validators (check dependencies)

4. **Create first end-to-end test**:
   - Simple patch that changes one function
   - Use CLI to install
   - Verify game behavior changes

---

## Questions/Decisions Needed

- **TOML library choice**: toml++ vs cpptoml vs toml11?
- **PE manipulation library**: PeNet vs AsmResolver?
- **Logging**: Use OutputDebugString or create log file?
- **Patch signing**: Future feature for security?
- **Auto-update**: Should patcher check for updates?

---

This document should give Claude Code (or any developer) complete context to continue implementation. All architectural decisions are documented, current state is clear, and next steps are prioritized.
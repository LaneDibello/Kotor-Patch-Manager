[[hooks]]
# Hook at the point right after CStr() is called and we have the string in EAX
# This is at address 0x005cb41c in ExecuteCommandAurPostString
address = 0x005cb41c

# The function exported from our patch DLL
function = "EnableAurPostString_Hook"

# Original bytes at 0x005cb41c (used for verification only):
# We verify the first 5 bytes to ensure we're patching the right location
original_bytes = [0x8d, 0x4c, 0x24, 0x0c, 0xc7]

# Stolen bytes: The complete instructions we need to execute in the wrapper
# These must align with instruction boundaries and be >= 5 bytes
# 8d 4c 24 0c                LEA ECX, [ESP+0xc]              (4 bytes)
# c7 44 24 1c ff ff ff ff    MOV dword ptr [ESP+0x1c], -1   (8 bytes)
# Total: 12 bytes
stolen_bytes = [0x8d, 0x4c, 0x24, 0x0c, 0xc7, 0x44, 0x24, 0x1c, 0xff, 0xff, 0xff, 0xff]

# Hook type: inline
# This means we'll replace the original code with a JMP to our wrapper
# The wrapper system will:
# 1. Save all registers
# 2. Call our function
# 3. Restore all registers
# 4. Execute the original instructions we overwrote
# 5. Jump back to continue execution
type = "inline"

# We need to preserve EAX since it contains the string pointer
# But actually, the wrapper system preserves all registers by default for inline hooks
# We don't need to exclude anything from restoration since we're just calling a function
exclude_from_restore = []


[[hooks.parameters]]
source = "eax"        # string from EAX register
type = "pointer"

[[hooks.parameters]]
source = "esp+0"      # x from [ESP]
type = "int"

[[hooks.parameters]]
source = "esp+4"      # y from [ESP+4]
type = "int"

[[hooks.parameters]]
source = "esp+8"      # life from [ESP+8]
type = "float"